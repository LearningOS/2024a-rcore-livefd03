# 1
RustSBI version 0.3.0-alpha.4, adapting to RISC-V SBI v1.0.0
bad_address 触发寻址异常
bad_instructions 触发指令异常，使用了s态的指令
bad_register 触发指令异常，指令中包含了无权访问的csr寄存器
# 2
## 1 L40：刚进入 __restore 时，a0 代表了什么值。请指出 __restore 的两种使用情景。
刚进__restore时，a0为当前内核态task的TaskContext地址。
使用场景一，通过在内核栈上构造用户态上下文和内核态上下文，切换到新task的内核栈上执行，跳转到__restore,启动一个新的的task；
使用场景二，作为用户态系统调用结束后的处理，从内核态返回用户态
## 2.L43-L48：这几行汇编代码特殊处理了哪些寄存器？这些寄存器的的值对于进入用户态有何意义？
这几行汇编分别还原了sstatus，sepc，sscratch寄存器
sstatus包含进入trap时机器的特权级别，可能从用户态进入trap或者发生中断嵌套，在sret时需要用到
sepc为用户态调用ecall指令时硬件保存的用户态pc指针,返回用户态决定了从哪条指令继续执行
sscratch寄存器为用户态栈指针，需要在sret切换到用户态之前和sp交换
## 3.restore为何跳过x2和x4
restore时x2为内核进程栈指针，x4为线程指针
刚开始x2为包含应用上下文的内核sp指针，还需要依赖sp还原用户态上下文，用户态上下文还原后使用`csrrw sp, sscratch, sp`还原sp寄存器
x4为应用进程指针，未用到
## 4.L60 csrrw指令后sp和sscratch中的值分别有什么意义？
用户进程的栈指针，内核进程的栈指针
## 5.__restore中发生状态切换在哪一条指令？为何该指令执行之后会进入用户态？
sret，用户态陷入内核态时sepc寄存器保存了用户态陷入内核态时的指令地址, sret指令跳转到ra寄存器地址并切换为s态
## 6.L13 csrrw指令后sp和sscratch中的值分别有什么意义？
内核进程的栈指针，用户进程的栈指针
## 7.从U态进入S态是哪一条指令发生的？
ecall

# 补充说明

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

无

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

https://riscv.org/wp-content/uploads/2019/12/riscv-spec-20191213.pdf
https://git.ustc.edu.cn/gaoway/ustc_ca2021_lab/-/tree/master/References

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。